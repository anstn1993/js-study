//closure는 js의 두 가지 특징으로 인해 일어나는 것이다.
//1. 함수를 정의하지 않고 객체로 만든다.
//2. 함수가 객체이기 때문에 인자로 전달될 수도 있고 함수 안에서 또 만들어질 수 있다. 

function f1() {
    var a = 1;

    return a;
}

var a = f1();
console.log(a);

//이 경우에는 a가 지역 변수이기 때문에 return되는 순간에 함수의 자원은 해제가 된다. 
//그런데 js는 함수가 함수를 포함할 수 있다.

function f1 () {
    var a = 1;

    return function f2() {
        return a;
    }
}

var f = f1();
var a = f();
console.log(a);


//위의 경우를 보면 f1함수가 반환 값으로 함수를 반환한다.
//문제는 그 함수가 반환하는 값이 f1함수의 지역변수라는 점이다.
//이렇게 되면 f1함수는 f2함수가 호출되기 전까지 자원을 반납하지 못 하게 된다. 
//f1이 자원을 반납해버리면 지역변수 a가 사라지게 되고 그럼 그 값을 반환하는 f2함수가 실행되지 못 하기 때문이다.
//그래서 변수 f가 f1함수를 계속 참조하고 있는 한 f1함수는 스택에서 제거되지 못 하고 남게 되는 것이다. 
//f변수가 다른 값이나 null을 참조해야만 자원 반납이 가능해진다. 

//이 상황에서 closure는 f2함수가 된다. f1함수를 종료시켜줄 수 있는 존재라는 의미다.

